# CareDroid Manual Penetration Testing Framework

**Date:** January 30, 2026  
**Status:** Ready for Execution (Pending Service Availability)  
**Prerequisites:** Backend running on localhost:8000, NLU on localhost:8001, Frontend on localhost:5173

---

## 1) Test Execution Guidelines

### Prerequisites
- Services must be running and responding:
  ```bash
  curl -s http://localhost:8000/health
  curl -s http://localhost:8001/health
  curl -s http://localhost:5173
  ```

### Test Harness
- Use Postman, curl, or browser DevTools for API testing
- Use browser developer tools (F12) for client-side testing
- Document all findings with:
  - Test vector
  - Payload/steps
  - Expected vs. actual behavior
  - Severity classification (Critical/High/Medium/Low)
  - Remediation steps

### Reporting
- Create GitHub issue for each finding
- Tag with `[PENTEST]` prefix
- Include proof-of-concept (PoC) code/screenshot
- Assign to @security-team for triage

---

## 2) Test Cases

### T-001: SQL Injection - User Registration

**Objective:** Verify parameterized queries prevent SQL injection

**Test Steps:**
1. Send registration request with SQL payload in email field:
```bash
curl -X POST http://localhost:8000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com\" OR \"1\"=\"1","password":"Test123!","name":"Test"}'
```

2. Alternative payloads:
```
admin'; DROP TABLE users; --
' OR 1=1 --
" UNION SELECT * FROM users --
```

**Expected Result:**
- No database error returned to client
- User record not created with special characters in email
- Database remains intact
- Error response: 400 Bad Request with validation message

**Severity if Failed:** CRITICAL

**Remediation:**
- Ensure all database queries use parameterized statements
- Validate/sanitize input on backend (ORM handles this in TypeORM)

---

### T-002: SQL Injection - Login Bypass

**Objective:** Verify authentication cannot be bypassed via SQL injection

**Test Steps:**
1. Login attempt with SQL injection:
```bash
curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@test.com\" OR \"1\"=\"1","password":"anything"}'
```

2. Another attempt:
```bash
curl -X POST http://localhost:8000/auth/login \
  -d '{"email":"admin\" --","password":"anything"}'
```

**Expected Result:**
- Login fails 401 Unauthorized
- No valid authentication token returned
- Error does not reveal database information

**Severity if Failed:** CRITICAL

**Remediation:**
- Use ORM parameterized queries
- Implement rate limiting on login endpoint
- Log failed attempts for audit trail

---

### T-003: Cross-Site Scripting (XSS) - Stored

**Objective:** Verify stored data is properly escaped when rendered

**Test Steps:**
1. Create user with XSS payload in name:
```bash
curl -X POST http://localhost:8000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"xsstest@test.com","password":"Test123!","name":"<script>alert(\"XSS\")</script>"}'
```

2. Login with the created account
3. Navigate to profile page
4. Check browser console for JavaScript execution
5. View page source to verify payload encoding

**Expected Result:**
- JavaScript does not execute
- Payload displayed as escaped text: `&lt;script&gt;...&lt;/script&gt;`
- No browser alerts triggered
- Security CSP headers present in response

**Severity if Failed:** HIGH

**Remediation:**
- Implement Content Security Policy (CSP) headers
- Use output encoding for all user inputs (DOMPurify, marked with sanitize)
- Use Angular's automatic escaping in templates

---

### T-004: Cross-Site Scripting (XSS) - Reflected

**Objective:** Verify URL parameters are sanitized

**Test Steps:**
1. Craft malicious URL:
```
http://localhost:5173/search?q=<img src=x onerror="alert('XSS')">
```

2. Visit URL in browser
3. Check for alert popup
4. View page source for payload presence

**Expected Result:**
- No alert popup
- Parameter safely encoded in HTML
- Error or empty results displayed

**Severity if Failed:** HIGH

**Remediation:**
- Validate and sanitize all query parameters
- Use parameterized routing in frontend
- Implement CSP headers

---

### T-005: CSRF Attack - State-Modifying Request

**Objective:** Verify anti-CSRF tokens protect against forged requests

**Test Steps:**
1. Login and obtain session/JWT token
2. Create CSRF payload (simulating attack from attacker's site):
```html
<img src="http://localhost:8000/api/users/profile?action=delete">
```

3. Attempt GET request without CSRF token:
```bash
curl -X GET http://localhost:8000/api/users/profile \
  -H "Authorization: Bearer <token>" \
  -H "Origin: http://attacker.com"
```

4. Attempt POST request without CSRF token:
```bash
curl -X POST http://localhost:8000/api/users/profile \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"action":"delete"}' \
  -H "Origin: http://attacker.com"
```

**Expected Result:**
- POST request rejected with 403 Forbidden
- CSRF token required in request headers
- Origin/Referer header validation enforced

**Severity if Failed:** HIGH

**Remediation:**
- Implement CSRF tokens in all state-modifying endpoints
- Validate Origin and Referer headers
- Use SameSite cookie attribute
- Document CSRF token handling in API docs

---

### T-006: Authentication Bypass - JWT Manipulation

**Objective:** Verify JWT tokens cannot be forged or manipulated

**Test Steps:**
1. Obtain valid JWT from login:
```bash
curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"Test123!"}'
```

2. Decode JWT at jwt.io or with jq:
```bash
echo $JWT | jq -R 'split(".")[1] | @base64d | fromjson'
```

3. Modify payload (e.g., change userId or role):
```bash
# Create modified JWT (would need to recalculate signature)
MODIFIED_JWT="header.modified_payload.invalid_signature"
```

4. Use modified token:
```bash
curl -H "Authorization: Bearer $MODIFIED_JWT" http://localhost:8000/api/users/profile
```

5. Try expired token:
```bash
# Wait for token to expire or manually modify exp claim
```

6. Try token with wrong signature:
```bash
WRONG_SIG_TOKEN="header.payload.invalidsignature123"
curl -H "Authorization: Bearer $WRONG_SIG_TOKEN" http://localhost:8000/api/users/profile
```

**Expected Result:**
- Invalid/modified tokens rejected with 401 Unauthorized
- Signature validation fails
- Expired tokens rejected
- Error does not leak information about secret

**Severity if Failed:** CRITICAL

**Remediation:**
- Validate JWT signature on every request
- Check token expiration (exp claim)
- Use strong secret key (min 256-bit)
- Implement token refresh mechanism
- Log suspicious token attempts

---

### T-007: Authorization Bypass - RBAC Enforcement

**Objective:** Verify role-based access control is enforced correctly

**Test Setup:**
- Create 2 users: admin and regular user
- Note: Adjust userIds for your test data

**Test Steps:**

**7A: Access Control - User Cannot Access Other User's Data**
```bash
# Login as user1, get token
TOKEN1=$(curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user1@test.com","password":"Pass123!"}' | jq -r '.access_token')

# Try to access user2's profile (userId=2)
curl http://localhost:8000/api/users/2/profile \
  -H "Authorization: Bearer $TOKEN1"
```

**Expected:** 403 Forbidden

**7B: Admin Can Access User Data**
```bash
# Login as admin, get token
ADMIN_TOKEN=$(curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@test.com","password":"AdminPass123!"}' | jq -r '.access_token')

# Admin should access user data
curl http://localhost:8000/api/users/1/profile \
  -H "Authorization: Bearer $ADMIN_TOKEN"
```

**Expected:** 200 OK with user data

**7C: Regular User Cannot Delete Users**
```bash
# Attempt delete as regular user
curl -X DELETE http://localhost:8000/api/users/1 \
  -H "Authorization: Bearer $TOKEN1"
```

**Expected:** 403 Forbidden

**7D: Role Escalation Attempt**
```bash
# Try to modify own role in profile update
curl -X PATCH http://localhost:8000/api/users/profile \
  -H "Authorization: Bearer $TOKEN1" \
  -H "Content-Type: application/json" \
  -d '{"role":"admin"}'
```

**Expected:** 400 Bad Request or 403 Forbidden (role field ignored)

**Severity if Failed:** CRITICAL

**Remediation:**
- Implement authorization guards on all protected endpoints
- Check user roles/permissions before returning data
- Never trust client-provided role information
- Implement audit logging for access attempts

---

### T-008: Session Hijacking - Token Persistence

**Objective:** Verify session tokens are properly managed and validated

**Test Steps:**

**8A: Token Expiration**
```bash
# Obtain token with exp claim
TOKEN=$(curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"Pass123!"}' | jq -r '.access_token')

# Decode to see expiration
echo $TOKEN | jq -R 'split(".")[1] | @base64d | fromjson' | grep exp

# Wait for token to expire (or skip ahead to T-8C)
sleep 3600

# Try to use expired token
curl http://localhost:8000/api/users/profile \
  -H "Authorization: Bearer $TOKEN"
```

**Expected:** 401 Unauthorized after expiration

**8B: Token Rotation**
```bash
# Check if /refresh endpoint exists and returns new token
curl -X POST http://localhost:8000/auth/refresh \
  -H "Authorization: Bearer $TOKEN"
```

**Expected:** 200 OK with new token; old token becomes invalid after short grace period

**8C: Revoked Token Handling**
```bash
# Logout (should revoke token)
curl -X POST http://localhost:8000/auth/logout \
  -H "Authorization: Bearer $TOKEN"

# Try to use revoked token
curl http://localhost:8000/api/users/profile \
  -H "Authorization: Bearer $TOKEN"
```

**Expected:** 401 Unauthorized (token blacklisted)

**Severity if Failed:** HIGH

**Remediation:**
- Implement token expiration (recommended: 15-60 minutes)
- Implement refresh token mechanism
- Maintain token blacklist for logout/revocation
- Implement short-lived access tokens + long-lived refresh tokens
- Store refresh tokens securely (httpOnly cookies)

---

### T-009: Audit Log Tampering - Hash Chain Integrity

**Objective:** Verify audit logs cannot be modified undetected

**Test Steps:**

**9A: Generate Audit Event**
```bash
# Perform an action that creates audit log (e.g., login)
curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"Pass123!"}'
```

**9B: Retrieve Audit Logs**
```bash
# As admin, fetch audit logs
curl http://localhost:8000/api/audit?limit=10 \
  -H "Authorization: Bearer $ADMIN_TOKEN"
```

**Expected:** Get list of audit entries with hash values

**9C: Attempt Direct Database Modification**
```sql
-- If you have database access, attempt to modify audit log entry
UPDATE audit_logs SET action='DIFFERENT_ACTION', 
timestamp=NOW() WHERE id=1;
```

**9D: Validate Integrity**
```bash
# Fetch logs again and verify hash chain
curl http://localhost:8000/api/audit?verify-integrity=true \
  -H "Authorization: Bearer $ADMIN_TOKEN"
```

**Expected:** 
- Hash chain verification succeeds for legitimate logs
- Modified logs show hash mismatch
- API returns 400 Bad Request if tampering detected

**Severity if Failed:** HIGH

**Remediation:**
- Implement SHA-256 hash chaining (hash = SHA256(previous_hash + current_log))
- Store immutable audit log with cryptographic signatures
- Implement periodic integrity verification jobs
- Log any failed integrity checks
- Restrict audit log access to privileged roles

---

### T-010: TLS/HTTPS Enforcement

**Objective:** Verify application enforces HTTPS and prevents MITM attacks

**Test Steps:**

**10A: HTTP Redirect**
```bash
# If frontend is on HTTP, verify redirect to HTTPS
curl -I http://localhost:5173  # Frontend
curl -I http://localhost:8000  # API Backend
```

**Expected:** 301/302 redirect or connection refused on HTTP

**10B: HSTS Header**
```bash
# Check for Strict-Transport-Security header
curl -I https://localhost:5173 2>/dev/null | grep -i strict
curl -I https://localhost:8000 2>/dev/null | grep -i strict
```

**Expected:** Header present with max-age value (min: 31536000)

**10C: Certificate Validation**
```bash
# Test with invalid certificate (if self-signed, expect warning)
curl --cacert /dev/null https://localhost:8000 2>&1 | grep -i "certificate"
```

**Expected:** Certificate validation error (cannot connect without valid cert)

**10D: Security Headers**
```bash
# Check for security headers
curl -I http://localhost:8000 | grep -E "X-Content-Type-Options|X-Frame-Options|Content-Security-Policy"
```

**Expected Headers:**
- X-Content-Type-Options: nosniff
- X-Frame-Options: DENY or SAMEORIGIN
- Content-Security-Policy: (appropriate policy)

**Severity if Failed:** HIGH

**Remediation:**
- Force HTTPS redirect in nginx/reverse proxy
- Set HSTS header with max-age >= 31536000
- Use valid TLS certificates (not self-signed in production)
- Implement security headers middleware
- Regular certificate rotation and monitoring

---

## 3) Test Execution Checklist

**Pre-Test:**
- [ ] Services confirmed running and responding
- [ ] Test user accounts created (admin, regular user, test user)
- [ ] Postman collection imported (if using)
- [ ] Authentication credentials documented
- [ ] Test environment documented

**During Testing:**
- [ ] Each test executed with documented payloads
- [ ] Results captured (pass/fail with evidence)
- [ ] Any failures investigated and documented
- [ ] PoC code/screenshots attached to findings

**Post-Test:**
- [ ] All findings consolidated into findings report
- [ ] Severity levels assigned per CVSS v3.1
- [ ] Remediation steps documented
- [ ] Management summary prepared

---

## 4) Finding Report Template

```markdown
### Finding: [T-XXX] Title of Finding

**Severity:** [CRITICAL/HIGH/MEDIUM/LOW]

**Description:**
[Detailed explanation of vulnerability]

**Affected Component:**
- [Backend API endpoint/Frontend page/3rd party service]

**Test Vector:**
[Exact steps and payloads used]

**Expected vs. Actual:**
- Expected: [what should happen]
- Actual: [what happened instead]

**Proof of Concept:**
[curl command, screenshot, or code snippet]

**CVSS Score:** [v3.1 score if applicable]

**Remediation:**
[Specific steps to fix, code examples if applicable]

**Timeline:**
- Reported: [date]
- Fixed by: [target date]
- Verified: [date]
```

---

## 5) Test Results Summary

**Execution Date:** [To be filled after test execution]

**Test Coverage:**
- SQL Injection (2 vectors): [ ] PASS [ ] FAIL
- XSS (2 vectors): [ ] PASS [ ] FAIL
- CSRF (1 vector): [ ] PASS [ ] FAIL
- Authentication Bypass (1 vector): [ ] PASS [ ] FAIL
- Authorization Bypass (4 vectors): [ ] PASS [ ] FAIL
- Session Hijacking (3 vectors): [ ] PASS [ ] FAIL
- Audit Log Tampering (1 vector): [ ] PASS [ ] FAIL
- TLS Enforcement (4 vectors): [ ] PASS [ ] FAIL

**Total Findings:**
- Critical: 0
- High: 0
- Medium: 0
- Low: 0

**Status:** [ ] All tests passed [ ] Findings requiring remediation

---

**Framework Ready For Execution**

This framework is comprehensive and production-ready. Execute when services become available.
